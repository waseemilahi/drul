%!TEX root =  Report.tex
% lessons learned, one section per team member

\chapter{Lessons Learned}

\section{Introduction}
In this chapter each team member tells about some lessons he learned from
the project, and what he would do differently if we had start all over
again.

\section{Rob (team leader)}

\section{Ben}

I was surprised and impressed with how effective pair programming turned out to be.
Leaving aside the technical issues, having  second check on "the obvious way to do things"
prevented me from getting into several potentially painful situations, when there was a
much simpler solution available (this is especially relevant when working with a new 
language, of course).

Despite the amount of work done with pair programming, we still ran into some 
forms of communication trouble.  In retrospect, a little more discussion up front
about standards for code format and design (and for version control use) would 
have been helpful, at least in theory (it's hard to have a 
coding standard for a language that you don't actually know).  
Our error messages ended up 
somewhat inconsistent, and our log messages were sometimes uninformative (especially at first):
better up-front coordination could have prevented those problems.  

It is tempting to say that a more careful up-front design would have been well-advised, since it would 
definitely have been helpful--but since we were creating something we didn't really know how to create,
using a language none of us was tremendously familiar with, it is unclear that spending more time on
up-front design would actually have been productive in this case.  
Smaller-scale design issues, on the other hand, would have benefitted from a bit more forethought:
we ended up with several somewhat inconsistent APIs for related helper functions, which could easily have been avoided by a little up-front communication or earlier and more aggressive refactoring.
We did refactor often to retrofit better design onto the code we had written (made simpler by the easy-to-run regression test suite), but more aggressive refactoring of minor concerns would probably have sped things up toward the end, and would certainly have left us  with a more maintainable final product.  The type-checking and type-inference features of OCaml make this form of refactoring much safer than it is in many languages, and we should have taken more advantage.

More importantly,from the moment that we had working code, we should have made more active use
of Subversion's branching capabilities, to avoid worries about breaking the main source tree while working on major features.  We ended up re-inventing branching at least once, and leaving the entire 
tree in a non-working state for a couple of evenings, which could readily have been avoided.


\section{Thierry}
One part of the code I especially worked on is the test suite, but I still
was surprised to see how important it turned out to be. In a new project,
I would either build a more powerful testing program, or spend more
time to find an appropriate package online. For instance, our current
testing program does not have the ability to test an output file instead
of the standard output. It would have become a problem if our language was
designed for file operations.

Another lesson learned is the importance of helper functions designed early.
At one point, every one of us had design is own method to lookup into the
environment, and obviously we multiplied the number of bugs. For some
functions, it is so obvious that they were going to be needed that we should
have spent the time, as a team, to define them. Their documentation is
also an important aspect when you work in a team of more than two programmers.

Following that idea, we probably did not use enough the ``issue tracking''
on Google code, the platform we used to host our project. Emails does not
work as well...

\section{Waseem}

Most important lesson in while coding in OCaml is to modularize the code.
Those match with clauses keep getting messier and also there is a lot of code 
repeatition while implementing similar functions or methods on the same language 
type object, e.g., pattern, clip, etc. Therefore, it is always good to have the 
helper functions, that can be used later on, in the code. This was my first group
project of this level and believe it or not, my first time using version control:); 
Really makes your life easier. Of course, having those lexer and parser tools do 
most of the work for you is vry helpful. OCaml in itself is a rather powerful language. 
Syntax tends to get 'messy', however, its power is well to be noted. The code tends 
to be compact, especially when you factor out code that is repeated.

Working in pairs is definitely more helpful than working on one thing alone. In the former
case you less likely tend to get stuck at a point, as compared to the later case. 

