\chapter{Project Plan}

\section{Processes}
* Identify process used for planning, specification, development and testing

Our plan was to complete tasks in the following order, working on tasks in paralell where possible:

\begin{enumerate}

\item Design DruL
\begin{itemize}
	\item Specify syntax
	\item Specify semantics
\end{itemize}

\item Write the LRM

\item Implement Basic Building Blocks
\begin{itemize}
	\item AST
	\item Scanner
	\item Parser
	\item Test Suite Driver
	\item Initial test cases
	\item Basic Interpreter (with evaluate, execute, and built-in print for string literals)
\end{itemize}

\item Implement Generic Language Features
\begin{itemize}
	\item Integer arithmetic
	\item Boolean operations
	\item Assignment statments and symbol table
	\item Selection statements
\end{itemize}

\item Implement Core DruL Language Features
\begin{itemize}
	\item Pattern creation and printing
	\item Pattern built-in functions and methods
	\item Map, mappers, and beats
	\item Named mappers
	\item Beat built-in methods
	\item Instrument definition
	\item Clip creation and printing
\end{itemize}

\item Implement Advanced DruL Language Features
\begin{itemize}
	\item Clip text output
	\item Clip MIDI output
	\item Clip Lilypond output
	\item Clip built-ins concat and repeat (not implemented)
\end{itemize}

\item Implement Fit and Finish
\begin{itemize}
	\item Interpreter command-line arguments
	\item Detailed error messages
	\item Error message line numbers
	\item Trapped parse errors
	\item Static semantic checks (not implemented)
\end{itemize}

\end{enumerate}

We initially used our own SVN server for source and documentation management.  However, we soon moved to Google Code to make used of its issues list for keeping track of bugs and the ToDo's correpsonding to the above features.

\section{Style Guide}
* Include a one-page programming style guide used by the team

Due to the fact that all of our team members started as novice OCaml programmers and OCaml's syntax is unlike any languages our team was already familiar with, we lacked much intuition regarding good OCaml coding style.  However, over the course of our coding, the following coding practice emerged:

\begin{itemize}
	\item Use hard tabs for indentation
	\item Specify pattern matched arguments and use ``match with'' syntax instead of the ``function'' shorthand for pattern matching
	\item Encapsulate each ``match with'' clause in parentheses
	\item Put each match case on a new line
	\item Indent each match case and put a tab after the ``$|$'' separator
	\item Begin results of a match case on the same line as the ``->''
	\item Indent subsequent lines of the results of a match case
	\item Horizontally align similar lines of code using extra whitespace
\end{itemize}

We never reached a conensus on whether to make our OCaml identifiers CamelCase or underscore\_separated.

\section{Timeline}
* Show your project timeline

\begin{tabular}{ | l | l | } \hline
	\textbf{Task} & \textbf{Date(s)} \\ \hline \hline
	Specify syntax & \\ \hline
	Specify semantics & \\ \hline
	Write the LRM & \\ \hline
	AST & \\ \hline
	Scanner & \\ \hline
	Parser & \\ \hline
	Test Suite Driver & \\ \hline
	Initial test cases & \\ \hline
	Basic Interpreter & \\ \hline
	Integer arithmetic & \\ \hline
	Boolean operations & \\ \hline
	Assignment statments and symbol table & \\ \hline
	Selection statements & \\ \hline
	Pattern creation and printing & \\ \hline
	Pattern built-in functions and methods & \\ \hline
	Map, mappers, and beats & \\ \hline
	Named mappers & \\ \hline
	Beat built-in methods & \\ \hline
	DruL GCD & \\ \hline
	Instrument definition & \\ \hline
	Clip creation and printing & \\ \hline
	Clip text output & Dec 15 \\ \hline
	Clip MIDI output & Dec 16-17 \\ \hline
	Interpreter command-line argument & Dec 16 \\ \hline
	Detailed error messages & Dec 16 \\ \hline
	Error message line numbers & Dec 16 \\ \hline
	Clip Lilypond output & Dec 17 \\ \hline
	Trapped parse errors & Dec 17 \\ \hline
	DruL song & Dec 17 \\ \hline
	Presentation slides & Dec 17-18 \\ \hline
	Report & Dec 18-19 \\ \hline
\end{tabular}

\section{Roles and Responsibilities}
* Identify roles and responsibilities of each team member

Each team member volunteered for the completion of tasks.  Tasks were not divied up amongst team members in advance.  Rather, afte team members finished their tasks they simply discussed what they should (or would like to) work on next with the rest of the team.  Many tasks (especially the more diffuclt ones) were tackled in pairs.  We found having an extra pair of eyes examining code and documentation as it was being written (i.e. paired programming) drastically cut down on the number of initial bugs and the amount of refactoring done later.

Below is a general description of the major tasks completed by each team member.  Paired efforts are noted in parentheses.  Note, that most work was with the group all in one room at one common table.  This allowed and individual or pair to ask for help or advice from the rest of the team.  This is done consistently and resulted with all members of the team being at least somewhat familiar with the impementation of almost all parts of the system.

\subsection{Rob}
\begin{enumerate}
	\item As team leader, resolved minor conflicts
	\item Proposed drumming language idea
	\item Setup intial SVN repository
	\item Wrote introduction for all documents
	\item Assisted with language design
	\item Wrote the Pattern, Map, and Mapper sections of the LRM
	\item Coded the AST (with Ben)
	\item Assisted with coding the parser
	\item Coded the initial ``helloworld'' interpreter (with Waseem)
	\item Coded pattern construct (with Ben)
	\item Coded DruL's built-in functions and methods and added corresponding test cases (with Waseem)
	\item Coded instrument and clip constructs (with Theirry)
	\item Performed built-ins code refactoring (with Ben)
	\item Performed code cleanup
	\item Refactored text output
	\item Coded MIDI output
	\item Wrote an example drum song using DruL
	\item Edited all the presentation slides
	\item Wrote the Project Plan section of the report
\end{enumerate}

\subsection{Ben}
\begin{enumerate}
	\item Decided on map/mapper idea
	\item Proposal???
	\item Assited with language design
	\item Wrote the Types, Statments, Blocks and Scoping sections of the LRM
	\item Coded the AST (with Rob)
	\item Assisted with coding the parser
	\item Coded the parse-tree dumper
	\item Coded selecton and assignment statements
	\item Coded pattern construct (with Rob)
	\item Coded map and mapper (with Theirry)
	\item Coded GCD implementation using DruL
	\item Refactored built-ins (with Rob)
	\item Refactored interpreter into smaller files
	\item Refactored scanner, parser, and interpreter to inculde line numbers in error messages with (with Thierry)
	\item Added tests for error messages
	\item Coded Coded Lilypond output
	\item Refactored output code
	\item Fixed corner-case symbol-table bugs
	\item Wrote parts 1 and 2 of the presentation (except for the mapper animation)
	\item Updated the LRM for the report (with Waseem).  Wrote the tutorial section of the report (with Waseem)
\end{enumerate}

\subsection{Thierry}
\begin{enumerate}
	\item Proposal???
	\item Assisted with language design
	\item Wrote the Instrument, Clip, and Output sections of the LRM
	\item Setup replacement Google Code repository
	\item Coded the test-suite driver
	\item Manualy created initial suite of test input and corresponding output files
	\item Assisted with coding the parser
	\item Coded map and mapper (with Ben)
	\item Coded named mapper
	\item Coded instruments and clip constructs (with Rob)
	\item Refactored scanner, parser, and interpreter to include line numbers in error messages (with Ben)
	\item Added tests for error messages (with Waseem)
	\item Fixed corner-case symbol-table bugs
	\item Wrote part 4 of the presentation
	\item Made the mapper animation for the presentation
	\item Wrote the testing section of the report
\end{enumerate}

\subsection{Waseem}
\begin{enumerate}
	\item Proposal???
	\item Assisted with lanuage design
	\item Wrote the Example Code section of the LRM
	\item Coded the scanner
	\item Assisted with coding the parser
	\item Coded the initial ``helloworld'' interpreter (with Rob)
	\item Coded DruL's built-in functions and methods and added corresponding test cases (with Rob)
	\item Coded text output
	\item Added tests for error messages (with Thierry)
	\item Wrote part 3 of the presentation
	\item Updated the LRM for the report (with Ben)
	\item Wrote the tutorial section of the report (with Ben)
\end{enumerate}

\section{Tools and Languages}
* Describe the software development environment used (tools and languages)

All of our source code was written using OCaml with the exception of the special syntaxes used by ocamllex and ocamlyacc, and the test-suite driver which was written in Python.

\subsection{Tools}

\begin{itemize}
\item \textbf{Lexer:} We used ocamllex to compile our ocamllex code into an Ocaml lexer/tokenizer, which given DruL source code, produces a token stream.

\item \textbf{Parser:} We used ocamlyacc to compile our ocamlyacc code into an Ocaml parser, which given a token stream, produces a DruL abstract-syntax-tree.

\item \textbf{MIDI Output:} MIDI (Musical Instrument Digital Interface) is a binary music protocal and file format that contains ``event messags'' for an audio device (e.g. a sound card or synthesizer).  MIDI files are playable on many common multimedia players (e.g. Quicktime).  DruL does not generate MIDI files directly.  Rather it uses midge, which is yet another music composition language that compiles to MIDI.  The language is not entirely different from DruL, however it allows for other instruments than drums and thus also has different note pitches and durations.  However, midge doesn't not have contructs for algorithmic compositions comparable to the power of DruL's.  In short, when DruL's outputMIDI method is called on a clip, the DruL interpreter produces midge code which is then piped to midge to produce the desired MIDI output file.

\item \textbf{Lilypond:} Lilypond is a typesetting lanuage.  DruL can produce Lilypond files.  These output files can then be compiled into typeset PDF's (of sheetmusic) using Lilypond.  DruL does not automate this however.

\end{itemize}

\subsection{Code Editors}

No one on our used the same code editor.  None of us used an IDE.  Team members used the following editors for all of their code (OCaml, latex, etc.):

\begin{itemize}
\item \textbf{Rob:} jEdit
\item \textbf{Ben:} BBEdit
\item \textbf{Thierry:} emacs
\item \textbf{Waseem:} gedit
\end{itemize}

\subsection{Documentation}
All documentation was produced using LaTeX with the exception of the presentation, which was made using Microsoft PowerPoint.

\subsection{Version Control}
We used Google Code and Subversion (SVN) for our source version control and issue tracking.

\section{Project Log}

See \ref{svnlog} in the Appendix for our Subversion commit log.

