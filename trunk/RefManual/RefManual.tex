\documentclass[11pt,twoside]{article}
 
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}

\pagestyle{plain}

\setlength{\voffset}{0pt}
\setlength{\marginparwidth}{0pt}
\setlength{\oddsidemargin}{30pt}
\setlength{\evensidemargin}{30pt}
\setlength{\textwidth}{400pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{10pt plus 2pt minus 1pt}

\title{\textbf{DruL} Reference Manual\\
\vspace{1cm}
COMS W4115: Programming Language and Translators}
\author{Team Leader: Rob Stewart (rs2660) \and Thierry Bertin-Mahieux (tb2332) \and Benjamin Warfield (bbw2108) \and Waseem Ilahi (wki2001)}

\begin{document}
\maketitle
\begin{center}
\end{center}

\vspace{3cm}

\begin{figure}[h]
\begin{center}
\includegraphics[width=.2\columnwidth]{Water_Drop.pdf}
\end{center}
\end{figure}


\newpage


\section{Introduction}
DruL is a programming language designed for composing drum music.  Unlike other more general-purpose music programming languages (ChucK, SuperCollider, Nyquist, Haskore), DruL's focus is on defining and manipulating beat patterns and is unconcerned with pitches, sound durations, or audio effects.

DruL is mainly an imperative programming language, however it borrows ideas (map and filter) from the functional paradigm.  In additions to integers, DruL's main datatypes are pattern and clip. Instruments are defined as constants.  See below for further details.

DruL programs do not contain any loops or user-defined functions.  All pattern 
and clip creation and manipulation is done using the map construct described below.

\section{Language Manual}

\subsection{Lexical Conventions}

\subsubsection{Comments}
Comments start with // and everything after them on that line
is considered a comment and is ignored. New line marks the end
of a comment.
\subsubsection{Whitespace}
Spaces, tab, end of line, and return are all considered the same 
and their only used is to seperate the tokens.

\subsubsection{Characters}
DruL uses the ASCII character set.

\subsubsection{Identifiers}
An identifier may be defined using any uppercase or lowercase character
or an underscore, followed by any set of uppercase or lowercase character,
underscore, and digits ($0$ through $9$). The maximum length of an identifier
is $64$.

All identifiers in a given scope, be they mapper names, variables, or built-in functions, belong to a single namespace.

\subsubsection{Keywords}


\begin{table}[htb]
\begin{center} 
\begin{tabular}{llll} 
  NULL &    rand &    clip &        mapper \\
  if &      pattern & instrument &  print \\
  elseif &  concat &  length &      output \\
  else &    slice &   map &         return
\end{tabular}
%\caption{\small{.}}
\label{tab:keywords}
\end{center} 
\end{table}


\subsection{Types}

There are $3$ basic types in DruL: \textbf{integer}s, \textbf{pattern}s,
and \textbf{clip}s.  In addition, 'string' constants may be used in DruL source code, but there is no variable type to which they can be directly assigned.
Likewise, boolean expressions exist, but can not be assigned to variables.
Values in DruL are strongly typed, but the type of a variable is determined dynamically.

\subsubsection{integer}
All integers are base 10, and may optionally be preceded by a sign ({\tt \textbf + -}).
Any sequence of digits ($0$ through $9$) is valid.  Leading $0$s are ignored, so a sequence such as $0000123$  is interpreted as $123$.  Integers are mutable.

\subsubsection{pattern}
A pattern is essentially an object that holds binary, discrete, time-series data.  At each discrete-time step, which will henceforth refer to as a beat, there is either a note or a rest.  For the non-musically inclined, a note represents sound produced by the striking of a drum (or similar instrument) and a rest represents the absence of any such sound.  Patterns are immutable.  When a pattern is manipulated, the target pattern remains intact and a new copy is created.  The length of a patten can be any non-negative integer.

\subsubsection{clip}

An instrument is one of a pre-defined set of sounds (e.g. drum notes) that can occupy a single beat.
A clip is a mapping of patterns to instruments. Clips are processed in sequence as the program runs to produce output which may be audio, sheet-music notation, or a MIDI file.  Clips are immutable.

\subsubsection{string}

A string constant begins with an ASCII double-quote character, continues 
with an arbitrary sequence of ASCII characters other than $\backslash$ and $''$, 
and concludes with another $''$ character.  If a $\backslash$ or $''$ character is 
desired, it can be escaped using the $\backslash$ character.

\subsection{Statements}

In the most common case, a statement consists of a single expression followed by a semicolon (``;'').  Importantly, unlike many languages with similar syntax, DruL does \emph{not} consider a block to be equivalent to a statement.  Instead, statements in DruL take one of the four forms below.



\subsubsection{Expression Statements}

The basic form of statement, as in most C-like languages, is the expression statement: \emph{expression-statement}: \emph{expression}\textbf{;}

The precedence table for operators in DruL is given here:

\begin{tabular}{ l |l| l}
\hline\hline
Operators & Notes & Associativity \\
\hline $ . $ & Method call & left to right \\
$-$  $!$ &Unary minus and logical negation & right to left \\
$*$ $/$ $\%$ & Standard C meanings & left to right \\
$+$ $-$ & Addition/subtraction & left to right \\
$<$ $<=$ $>$ $>=$ &  &  \\
$!=$ $==$ &  & \\
$\&\&$ &  & \\
$||$ &  & \\
\end{tabular}

The subsections that follow use the model of the C Language Reference Manual to indicate the various types of expression.  As in that example. the highest-precedence forms of expression are listed first.  Since much of the material below is extremely straightforward, plain-English descriptions are supplemented by grammatical descriptions only when necessary.

\paragraph{Primary Expressions}

A primary expression consists of a constant (integer or string), an identifier, or a parenthesized expression.

\paragraph{Function and Method calls}
Functions and method calls associate right to left.  Depending on the function or method in question, they may return values of any type, including boolean values (which cannot be assigned to variables). Arguments to function and method
calls are passed by value, not by reference.

\emph{arglist}: \textbf ( \emph{expression} \textbf ) $|$  \textbf ( \emph{expression} 
$<$SPACE$>$ \emph{arglist} \textbf )

\emph{method-call} : \emph{identifier} \textbf . \emph{identifier arglist} 

\emph{function-call} : \emph{identifier} \emph{arglist} $|$ \textbf{map} \emph{arglist mapper}

\emph{mapper} : \emph{identifier} $|$ \emph{block}

\emph{block} : \textbf{\{} \emph{statement-list} \textbf{\}} 

\emph{statement-list}: \emph{statement} $|$ \emph{statement statement-list}



\paragraph{Unary operations}
The unary operations in DruL are arithmetic and logical negation (unary $-$ and $!$).  Since DruL is strictly typed, arithmetic negation can only be applied to integer values, and logical negation to boolean values.

\paragraph{Standard arithmetic operations}

Expressions may use the standard binary arithmetic operators ($+$, $-$, $*$ and $/$), with their standard precedence.  It is required that both of the operands in such an expression be integer values.

\paragraph{Comparison operations}

As in most C-family languages (and as shown in the precedence table above), relational operators have precedence over equality tests.  These operators return boolean values, which can be used in \textbf{if} statements but cannot be assigned to variables.

Relational tests may be used on integer values only; equality tests can be used on variables of any type, but in the case of patterns and clips, they will only report whether the two variables being tested are  aliases of the same object, not any deeper notion of equivalence.

\paragraph{Logical combination operations}

Here again we follow the conventions of C, and give $\&\&$ precedence over $||$.  These operators require their operands to be boolean values, and return boolean values.

\subsubsection{Assignment Statements}

Assignment in DruL is not a simple operator to be placed in the middle of an expression.  Rather, it is a separate type of statement, which may appear anywhere another statement may appear.  

\begin{center}
\emph{assignment-statement}: \emph{identifier} \textbf{=}  \emph{expression-statement};
\end{center}

Assignment is polymorphic: the same syntax is used to assign variables to
integers, patterns and clips. Furthermore, due to DruL's dynamic typing,
a variable may be reassigned to a different type.

\subsubsection{Selection Statements}

Selection statements in DruL take the following form: the string \textbf{if}, followed by an expression that returns a boolean result, enclosed in parentheses, followed by an open-brace (``\{''), one or more statements, and a close-brace (``\}'').  This may optionally be followed by one or more \textbf{elseif}s, which are also followed by parentheses and a block of statements, and one (optional) \textbf{else}, which omits the test expression but is also followed by a block of statements.

\emph{selection-statement} : \textbf{if ( } \emph{boolean-expression} \textbf{ )}\emph{block if-tail}

\emph{if-tail} : $\epsilon$ $|$ \emph{if-middle} $|$
	\emph{if-middle} \textbf{else \{} \emph{statement-list} \textbf{\}} 

\emph{if-middle} : $\epsilon$ $|$   \textbf{elseif ( } \emph{boolean-expression} \textbf{ ) \{} \emph{statement-list} \textbf{\}} \emph{if-middle} 

\subsubsection{Mapper Definition Statements}

A mapper definition consists of the word \textbf{Mapper}, followed by an identifier, followed by a parenthesized list of space-separated identifiers, followed by a block.

\emph{mapper-definition} : \textbf{Mapper} \emph{identifier namelist block} \textbf{;}

\emph{namelist}: \textbf ( \emph{identifier} \textbf ) $|$  \textbf ( \emph{identifier} 
$<$SPACE$>$ \emph{namelist} \textbf )


\begin{verbatim}
Mapper name (arg1 arg2  arg3)
{
    statement-list
};
\end{verbatim}

\subsection{Blocks, namespace and scoping}

\subsubsection{Blocks}
DruL has a limited block structure: only in the context of an \textbf{if}/\textbf{elseif}/\textbf{else} sequence or a Mapper Definition statement is a new block needed or allowed.  In these cases, curly braces (``\{\}'') are used to delimit the statement-sequence that falls within the block, and they must contain one or more statements.

Mapper definitions define a new closed scope (one from within which externally defined variables are not visible); \textbf{if} blocks do not define a new scope, so all variables used within them are visible to the enclosing  block, and vise-versa.

\subsubsection{Namespace}
DruL has a namespace shared by variables, built-in functions and 
mapper names. Additionally, each type has an associated namespace for methods.

\subsubsection{Scoping}
DruL has one top level scope and one scope per each mapper
(named or anonymous). Mapper scopes may be nested.
Each scope has read-only access to all variables and mapper names
defined in the scopes above it in the scope hierarchy.
This allows for recursive mappers.

\subsection{Patterns and pattern operations}

\subsubsection{Patterns}
A pattern is a set of beats, each beat can be a note or a rest.
To declare a pattern, DruL uses `0' for rests and `1' for notes.
A pattern can be created in the following way:
\begin{verbatim}
  p1 = pattern("101010");
\end{verbatim}
which represents the sequence {note, rest, note, rest, note, rest}.
Its length is $6$. If the character is a 1, there is a note on the
corresponding beat; if 0, a rest.

There are simple operations of patterns included in DruL. We
can repeat a pattern:
\begin{verbatim}
  p2 = pattern("100");
  p3 = p2.repeat(3);
  p4 = pattern("100").repeat(3);
\end{verbatim}
p3 is "100100100" and so is p4. Two patterns can be concatenated:
\begin{verbatim}
  p5 = pattern("111");
  p6 = pattern("000");
  p7 = concat(p5 p6);
\end{verbatim}
p7 is "111000". \textbf{concat} can take any positive number of
patters as argument, patterns are concatenated from left to right.
Finally, you can have an empty pattern of length 0:
\begin{verbatim}
  p8 = pattern("");
\end{verbatim}


\subsubsection{Map}
A map is used to perform an operation iteratively on a set of patterns.
Patterns are iterated over from left to right. The output of a map is
a pattern. For example:
\begin{verbatim}
  p9 = pattern("101");
  p10 = map(p9) {if ($1.note) {return pattern("11")'} else {return  pattern("0");}};
\end{verbatim}
p10 is "11011". Inside an anonymous mapper, DruL uses the symbol \$1 to refer
to the first pattern (here p9), \$2 for the second, etc.
DruL uses \textbf{\$1.note} or \textbf{\$1.rest} to check whether
the current beat is a note or a rest, 'p' being the name of the input pattern.
\textit{\$1.note} returns \textit{true} if there is a note on the current beat, 
\textit{false} otherwise. We use map to create meaningful new patterns from 
existing ones. If you call map on multiple patterns that are not of the same
length, the shorter patterns will be padded with \textit{NULL} beats.


\subsubsection{Mapper}
A mapper is the body of a map. It is used when a same operation has to be
used multiple times, over different sequences.
For example, the previous example could have been written in the following
way:
\begin{verbatim}
  mapper mymapper (p)
  {
      if (p.note) { return pattern("11"); }
      else        { return pattern("0");  }
  };
  p10 = map(p9) mymapper;
\end{verbatim}
Mapper has to be declared before it is used in the file.
We introduce $2$ new features as built-in methods that can be used inside
a \textit{map}: \textit{prev} and \textit{next}. They give you access to
earlier and later beats in a pattern, using the syntax \textit{p.prev(n)}
and \textit{p.next(n)}. 

Not that the patterns are now referred by their name (in the argument list).
However, one can still use \$1, \$2, \$3, ... as defined in the previous
section.

%Also, for a pattern \textit{p}, \textit{p.rest} is
%true if and only if we did not reach the end of this pattern.

\subsection{Clips}

\subsubsection{Instruments}

Before we define any clips, we must tell the compiler what instruments they will use.
This can only be done once per program, and uses the instruments function.  This function is unique in that it can take a variable number of arguments.  Each argument is the name of an instrument to be defined.  In the example below, four instruments are defined:

\begin{verbatim}
instruments(hihat bassdrum crash snare);
\end{verbatim}

Instruments must be defined at the beginning of a DruL program, before any clips have been defined.

\subsubsection{Clips}

A clip represents a collection of patterns to be played in parallel, where each pattern is played on a single instrument.
Once the instruments are defined, we can create a clip from our existing patterns, using an
associative-array notation:

\begin{verbatim}
clip1 = clip
(
    bassdrum = downbeats
    hihat    = alternate_beats
);
\end{verbatim}
The same result can be achieved by simply listing the patterns for each instrument in the order they are defined in the \textit{instruments} declaration:
\begin{verbatim}
clip2 = clip				// remaining instruments have an empty beat-pattern
(
    alternate_beats
    downbeats    
);

\end{verbatim}
The patterns passed into clips are passed by value, not by reference.



\subsection{Outputs}
DruL has two kinds of outputs, the first one display a straightforward
representation of some data, the second one transform a clip into a
more complex representation, like MIDI.

\subsubsection{Standard output}
The \textbf{print} statement displays any type to the standard
output, including strings. For example:
\begin{verbatim}
  print "DruL";
  print pattern("01");
\end{verbatim}
The representation of a string is the string itself. The representation
of a pattern is the string that would have been used to initialized
the pattern. For example, if we have a pattern
\begin{verbatim}
  p = pattern("01").repeat(2); //p = 0101
\end{verbatim}

\subsubsection{Text}
Similar as \textbf{print}, DruL can output the representation of any type 
to a file. The command is:
\begin{verbatim}
  output.file("myfile.txt","DruL");
  output.file("myfile.txt",pattern("01"));
\end{verbatim}

\subsubsection{MIDI}
The function \textbf{output.midi("my.file",clip,tempo)} outputs a clip as a MIDI
file with filename "my.file". \textbf{tempo} is a positive integer that
represents the beat per minute (BPM). 
The transformation from clip to MIDI may rely
on external libraries as MIDGE\footnote{\url{http://www.undef.org.uk/code/midge/}}. There is no guarantee on which of the three existing MIDI formats is used.

\clearpage

\section{Example Code}

The following example DruL code demonstrates the use of the basic functions of the language.
Consult the definitions above for verification purposes.

\begin{verbatim}
//This code manipulates some patterns, associate them to instruments and
//sends them to outputs.
//First the Instrument declaration. It has to be done before 
//any clip declaration, otherwise there will be a compile time error.

instruments(hihat bassdrum crash snare); //declare four instruments

//Integer variables used as tempos for clips.

a = 350;
b = 300;

//Patterns.

p1 = pattern("100100100");
p2 = pattern("");//empty pattern
p3 = pattern("0");//pattern with only one 'rest' in it.
p4 = pattern("1");//pattern with only one 'note' in it.

//pcat pcat is essentially concatenation of three patterns.

p_concat = concat(p1 pattern("11110000") pattern("00011"));

//Make a new pattern using above patterns and the library methods 'repeat' and 'slice'. 

p_custom = concat(p2 p3.repeat(2) p4.repeat(3) p3.repeat(2) p4.repeat(4) p_concat );
p_custom_new = concat(p_custom p3.repeat(2) p_concat p4.repeat(3));
p_new = concat( p_custom_new.slice(4,10) p_concat.slice(5,p1.length) p3.repeat(7) );

\end{verbatim}
\clearpage
\begin{verbatim}
//Now some complex pattern manipulation.

//New Patterns.

alternate_beats = pattern("10").repeat(8);
P_concat_new = concat(p_concat p_custom);

//Anonymous mapping.

p_new_rev = map (p_new)
{
    if (p_custom.rest) { pattern("1"); }
    else 					         { pattern("0");  }
};

//Mapper definitions. 

mapper newMapper1 (p_any)
{
    if (p_any.note) 			 { return pattern("1"); }
    else         					 { return pattern("");  }
};

mapper newMapper2 (p_any alternate_beats)
{
    if     (alternate_beats.rest) { return pattern("");  } // pattern of length 0
    elseif (p_any.note)   				{ return pattern("1"); }
    else                          { return pattern("0"); }
};

mapper improved_newMapper2(p_any alternate_beats)
{
    if     (alternate_beats.rest)      { return pattern("");  } // still required
    elseif (p_any.note)		             { return pattern("1"); }
    elseif (p_any.next(1).note)				 { return pattern("1"); }
    else                               { return pattern("0"); }
};

p_custom_new_notes 		 = map (p_custom_new) myMapper1;
p_concat_new_downbeats = map (p_concat_new) newMapper2;

//print out the created patterns to Standard Output.

print "Output from Sample DruL Code.\n"   //'\n' is for newline.
print p_concat;
print "\n";
print p_custom;
print "\n";
print p_custom_new;
print "\n";
print p_new;
print "\n\n";
print p_new_rev;
print "\n\n";
print p_custom_new_notes;
print "\n\n";
print p_concat_new_downbeats;
print "\n\n";
print "END OF OUTPUT\n\n";

//Pattern associations using clips.

clip_complete = clip
(
hihat		 = p_concat_new_downbeats
bassdrum = p_custom_new_notes
crash 	 = p_new_rev
snare		 = p_new
);

//output clip as a midi file
out.midi("out_file1.midi",clip_complete,a);//a = tempo (Beats per minute)

// Last instrument has an empty beat-pattern.
clip_partial = clip(p_concat p_custom_new p_custom);

//output clip as a midi file
out.midi("out_file2.midi",clip_partial,b);//b = tempo
\end{verbatim}

\end{document}